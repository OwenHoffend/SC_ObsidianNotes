
https://en.wikipedia.org/wiki/Interpolation
## Bilinear Interpolation
Bilinear interpolation linear scales between 4 control points $\mathbf{P_{00}}$ $\mathbf{P_{01}}$, $\mathbf{P_{10}}$, and $\mathbf{P_{11}}$ . Using the notation from [[Hardware Adaptive High-Order Interpolation for Real-Time Graphics|this paper]], it can be expressed with the following equation:
$$\mathbf{L}_{4}^{2D} = (1-s)(1-t)\mathbf{P_{00}}+s(1-t)\mathbf{P_{10}}+(1-s)t\mathbf{P_{01}}+st\mathbf{P_{11}}$$
Note: the use of "bi" in Bilinear refers to the fact that this is a 2-D interpolation operation. Where:
$$s=\frac{x - x_0}{x_1 - x_0} , \ \ t=\frac{y - y_0}{y_1 - y_0}$$
## Bicubic Interpolation
https://en.wikipedia.org/wiki/Bicubic_interpolation

Bicubic Interpolation fits a 2D cubic spline function based on 16 control points. It is analogous to the 1D spline interpolation shown [here](https://en.wikipedia.org/wiki/Spline_interpolation). The interpolation is done on a unit square, so there are four corner points (0,0), (1,0), (0,1), and (1,1). Each corner point has four values: The function value: $f$  and the derivatives $f_x$, $f_y$, and $f_{xy}$ . The interpolation is generated by solving a linear system of equations generated by the following equation:
$$p(x,y)=\sum_{i=0}^3\sum_{j=0}^3a_{ij}x^iy^j$$
On image data, the derivative terms can be estimated by looking at the surrounding pixels. For example, in the $x$ dimension we can compute: $f_x(0,0) \approx \frac{1}{2}(P_{10}-P_{-10})$. And $f_y(0,0) \approx \frac{1}{2}(P_{01}-P_{0-1})$. To find the cross-derivative $f_{xy}$, first compute the grid of x-derivatives, then compute the derivatives on *those* values in the y direction. Example: $f_{xy}(0,0) \approx \frac{1}{2}(f_x(0,1)-f_x(0,-1))$.